"""
Output Formatter
Editor ভাই-এর জন্য Multi-format Response Processing
"""

import json
import html
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
from pathlib import Path
import logging

from config import OUTPUT_TEMPLATES, config

class OutputFormatter:
    """Formats model responses into different output formats"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    def format_response(self, model_response: Dict, output_format: str = "json") -> Union[Dict, str]:
        """
        Format model response into specified output format
        
        Args:
            model_response: Response from model interface
            output_format: Desired output format (json, html, text, audio)
            
        Returns:
            Formatted response in specified format
        """
        try:
            if output_format == "json":
                return self._format_json(model_response)
            elif output_format == "html":
                return self._format_html(model_response)
            elif output_format == "text":
                return self._format_text(model_response)
            elif output_format == "audio":
                return self._format_audio(model_response)
            elif output_format == "code":
                return self._format_code(model_response)
            elif output_format == "conversation":
                return self._format_conversation(model_response)
            else:
                return self._format_json(model_response)  # Default fallback
                
        except Exception as e:
            self.logger.error(f"Error formatting response: {e}")
            return self._get_error_format(str(e))
    
    def _format_json(self, model_response: Dict) -> Dict:
        """Format response as JSON"""
        return {
            "response": {
                "content": model_response.get("content", ""),
                "language": self._detect_response_language(model_response.get("content", "")),
                "timestamp": model_response.get("timestamp", datetime.now().isoformat()),
                "model_used": model_response.get("model_used", "unknown"),
                "success": model_response.get("success", False),
                "audio_file": model_response.get("audio_path"),
                "metadata": model_response.get("metadata", {})
            },
            "system_info": {
                "version": "1.0.0",
                "agent": "ZombieCoder Agent (সাহন ভাই)",
                "processing_time": self._calculate_processing_time(model_response)
            }
        }
    
    def _format_html(self, model_response: Dict) -> str:
        """Format response as HTML"""
        content = model_response.get("content", "")
        language = self._detect_response_language(content)
        timestamp = model_response.get("timestamp", datetime.now().isoformat())
        model_used = model_response.get("model_used", "unknown")
        audio_path = model_response.get("audio_path")
        
        # Escape HTML content
        safe_content = html.escape(content)
        
        # Create audio player if audio exists
        audio_player = ""
        if audio_path:
            audio_player = f"""
            <audio controls>
                <source src="{audio_path}" type="audio/wav">
                আপনার ব্রাউজার অডিও সাপোর্ট করে না।
            </audio>
            """
        
        # Format using template
        html_content = OUTPUT_TEMPLATES["html"].format(
            content=safe_content,
            language=language,
            timestamp=timestamp,
            audio_player=audio_player
        )
        
        return html_content
    
    def _format_text(self, model_response: Dict) -> str:
        """Format response as plain text"""
        content = model_response.get("content", "")
        timestamp = model_response.get("timestamp", datetime.now().isoformat())
        model_used = model_response.get("model_used", "unknown")
        
        text_response = f"""
=== AI Response ===
Timestamp: {timestamp}
Model: {model_used}

{content}

---
Generated by ZombieCoder Agent (সাহন ভাই)
        """.strip()
        
        return text_response
    
    def _format_audio(self, model_response: Dict) -> Dict:
        """Format response with audio focus"""
        content = model_response.get("content", "")
        audio_path = model_response.get("audio_path")
        
        if not audio_path:
            # Generate audio if not present
            audio_path = self._generate_audio_fallback(content)
        
        return {
            "content": content,
            "audio_file": audio_path,
            "audio_available": audio_path is not None,
            "transcript": content,
            "timestamp": model_response.get("timestamp", datetime.now().isoformat()),
            "format": "audio"
        }
    
    def _format_code(self, model_response: Dict) -> Dict:
        """Format response for code-related queries"""
        content = model_response.get("content", "")
        
        # Extract code blocks
        code_blocks = self._extract_code_blocks(content)
        
        return {
            "content": content,
            "code_blocks": code_blocks,
            "language_detected": self._detect_code_language(code_blocks),
            "syntax_highlighted": self._apply_syntax_highlighting(code_blocks),
            "timestamp": model_response.get("timestamp", datetime.now().isoformat()),
            "format": "code"
        }
    
    def _format_conversation(self, model_response: Dict) -> Dict:
        """Format response for conversational queries"""
        content = model_response.get("content", "")
        language = self._detect_response_language(content)
        
        return {
            "content": content,
            "language": language,
            "tone": self._detect_tone(content),
            "suggestions": self._generate_conversation_suggestions(content, language),
            "timestamp": model_response.get("timestamp", datetime.now().isoformat()),
            "format": "conversation"
        }
    
    def _detect_response_language(self, content: str) -> str:
        """Detect language of the response content"""
        # Simple language detection based on character patterns
        bengali_chars = sum(1 for char in content if '\u0980' <= char <= '\u09FF')
        total_chars = len([char for char in content if char.isalpha()])
        
        if total_chars > 0 and bengali_chars / total_chars > 0.3:
            return "bengali"
        else:
            return "english"
    
    def _calculate_processing_time(self, model_response: Dict) -> Optional[float]:
        """Calculate processing time from metadata"""
        metadata = model_response.get("metadata", {})
        
        if "total_duration" in metadata:
            return metadata["total_duration"] / 1e9  # Convert nanoseconds to seconds
        
        return None
    
    def _extract_code_blocks(self, content: str) -> List[Dict]:
        """Extract code blocks from content"""
        import re
        
        code_blocks = []
        
        # Pattern for code blocks (```language\ncode\n```)
        pattern = r'```(\w+)?\n(.*?)\n```'
        matches = re.findall(pattern, content, re.DOTALL)
        
        for i, (language, code) in enumerate(matches):
            code_blocks.append({
                "id": i + 1,
                "language": language or "text",
                "code": code.strip(),
                "line_count": len(code.strip().split('\n'))
            })
        
        return code_blocks
    
    def _detect_code_language(self, code_blocks: List[Dict]) -> str:
        """Detect programming language from code blocks"""
        if not code_blocks:
            return "unknown"
        
        # Get the most common language
        languages = [block["language"] for block in code_blocks]
        return max(set(languages), key=languages.count) if languages else "unknown"
    
    def _apply_syntax_highlighting(self, code_blocks: List[Dict]) -> List[Dict]:
        """Apply basic syntax highlighting to code blocks"""
        highlighted_blocks = []
        
        for block in code_blocks:
            # Simple keyword highlighting (can be enhanced with libraries like Pygments)
            code = block["code"]
            language = block["language"]
            
            # Basic keyword highlighting for common languages
            if language in ["python", "py"]:
                keywords = ["def", "class", "import", "from", "if", "else", "for", "while", "return"]
                for keyword in keywords:
                    code = code.replace(keyword, f"<span class='keyword'>{keyword}</span>")
            elif language in ["javascript", "js"]:
                keywords = ["function", "var", "let", "const", "if", "else", "for", "while", "return"]
                for keyword in keywords:
                    code = code.replace(keyword, f"<span class='keyword'>{keyword}</span>")
            
            highlighted_blocks.append({
                **block,
                "highlighted_code": code
            })
        
        return highlighted_blocks
    
    def _detect_tone(self, content: str) -> str:
        """Detect the tone of the response"""
        content_lower = content.lower()
        
        # Positive indicators
        positive_words = ["ভাল", "চমৎকার", "দুর্দান্ত", "great", "excellent", "wonderful", "amazing"]
        negative_words = ["খারাপ", "ভুল", "সমস্যা", "bad", "wrong", "problem", "error", "issue"]
        
        positive_count = sum(1 for word in positive_words if word in content_lower)
        negative_count = sum(1 for word in negative_words if word in content_lower)
        
        if positive_count > negative_count:
            return "positive"
        elif negative_count > positive_count:
            return "negative"
        else:
            return "neutral"
    
    def _generate_conversation_suggestions(self, content: str, language: str) -> List[str]:
        """Generate follow-up conversation suggestions"""
        suggestions = []
        
        if language == "bengali":
            suggestions = [
                "আরও বিস্তারিত জানতে চান?",
                "অন্য কিছু জানতে চান?",
                "আরও উদাহরণ দরকার?",
                "কোনো প্রশ্ন আছে?"
            ]
        else:
            suggestions = [
                "Would you like to know more?",
                "Do you have other questions?",
                "Need more examples?",
                "Any other questions?"
            ]
        
        return suggestions[:3]  # Return top 3 suggestions
    
    def _generate_audio_fallback(self, content: str) -> Optional[str]:
        """Generate audio fallback if TTS failed"""
        try:
            # Simple fallback - could integrate with system TTS
            return None  # For now, return None
        except Exception:
            return None
    
    def _get_error_format(self, error_message: str) -> Dict:
        """Get error response format"""
        return {
            "error": True,
            "message": f"Formatting error: {error_message}",
            "timestamp": datetime.now().isoformat(),
            "content": "দুঃখিত, একটি ত্রুটি হয়েছে। অনুগ্রহ করে আবার চেষ্টা করুন।"
        }
    
    def get_supported_formats(self) -> List[str]:
        """Get list of supported output formats"""
        return ["json", "html", "text", "audio", "code", "conversation"]
    
    def validate_format(self, output_format: str) -> bool:
        """Validate if output format is supported"""
        return output_format in self.get_supported_formats()

# Example usage and testing
if __name__ == "__main__":
    formatter = OutputFormatter()
    
    # Test with sample model response
    test_response = {
        "content": "আপনার প্রশ্নের উত্তর: Python এ function লিখতে হলে def keyword ব্যবহার করতে হয়।\n\n```python\ndef hello_world():\n    print('Hello, World!')\n```",
        "model_used": "ollama_llama2",
        "timestamp": datetime.now().isoformat(),
        "success": True,
        "metadata": {"total_duration": 1500000000}
    }
    
    print("=== Output Formatter Test ===")
    
    # Test JSON format
    json_output = formatter.format_response(test_response, "json")
    print("JSON Format:")
    print(json.dumps(json_output, indent=2, ensure_ascii=False))
    
    print("\n" + "="*50)
    
    # Test HTML format
    html_output = formatter.format_response(test_response, "html")
    print("HTML Format:")
    print(html_output[:200] + "...")
    
    print("\n" + "="*50)
    
    # Test code format
    code_output = formatter.format_response(test_response, "code")
    print("Code Format:")
    print(json.dumps(code_output, indent=2, ensure_ascii=False))
